# Компонент Mouse Input Manager

## 1. Введение

`MouseInputManager` — это централизованный синглтон для обработки всех действий мыши в вашем проекте. Его главная цель — заменить множество вызовов `Input.GetMouseButtonDown` и `Physics.Raycast` в разных скриптах на единую, оптимизированную и событийно-ориентированную систему.

Вместо того чтобы каждый компонент самостоятельно проверял клики, он может просто подписаться на события этого менеджера. Это не только упорядочивает код, но и значительно повышает производительность, так как менеджер выполняет всего один рейкаст за кадр и спроектирован так, чтобы не создавать "мусор" (GC allocations).

---

## 2. Структура данных

### MouseEventData
Каждое событие мыши передает подписчикам структуру `MouseEventData`, которая содержит всю необходимую информацию о событии:
- `ScreenPosition` (`Vector2`): Позиция курсора на экране.
- `WorldPosition` (`Vector3`): Позиция курсора в мировом пространстве.
- `HitObject` (`GameObject`): Объект, по которому попал луч.
- `Hit3D` (`RaycastHit`): Полная информация о попадании в 3D-коллайдер.
- `Hit2D` (`RaycastHit2D`): Полная информация о попадании в 2D-коллайдер.

---

## 3. Описание класса

### MouseInputManager
- **Пространство имен**: Глобальное (является синглтоном `Neo.Tools.Singleton<MouseInputManager>`)
- **Путь к файлу**: `Assets/Neoxider/Scripts/Tools/Input/MouseInputManager.cs`

**Описание**
Этот компонент — синглтон. Если его нет в сцене при загрузке, он будет автоматически создан (объект `MouseInputManager` с `DontDestroyOnLoad`). Он отслеживает состояние левой кнопки мыши и вызывает соответствующие C#-события, на которые могут подписаться другие скрипты.

**Ключевые поля**
- `enablePress`, `enableHold`, `enableRelease`, `enableClick`: Флаги, позволяющие включать или отключать генерацию соответствующих событий для оптимизации.
- `interactableLayers` (`LayerMask`): Маска слоев, с которыми может взаимодействовать курсор. Все остальные слои будут проигнорированы.
- `fallbackDepth` (`float`): Глубина для расчета позиции курсора, если рейкасты никуда не попали.

### Поллинговый доступ к данным (без событий)
- `LastEventData` (`MouseEventData`, static): последние вычисленные данные события мыши.
- `HasEventData` (`bool`, static): есть ли валидные данные.
- `LastEventDataRef` (`ref readonly MouseEventData`): ссылка только для чтения на последние данные (без копирования).

Пример поллинга в `Update()`:
```csharp
void Update() {
    if (MouseInputManager.HasEventData) {
        ref readonly var d = ref MouseInputManager.LastEventDataRef;
        // использовать d.WorldPosition / d.HitObject и т.д.
    }
}
```

### Gizmos (редактор)
- `drawGizmos` (`bool`): Рисовать ли гизмо последней точки наведения/клика.
- `gizmoColor` (`Color`): Цвет сферы-гизмо.
- `gizmoRadius` (`float`): Радиус сферы-гизмо.
- `gizmoDrawText` (`bool`): Подписывать ли объект текстом.
- `gizmoTextColor` (`Color`): Цвет текста над объектом.
- `gizmoTextScale` (`float`): Масштаб текста (размер адаптируется к расстоянию через `HandleUtility`).
- `gizmoBaseFontSize` (`int`, по умолчанию 18): Базовый размер шрифта до масштабирования.
- `gizmoTextOffset` (`Vector3`): Смещение подписи относительно точки (по умолчанию немного выше центра; учитывается радиус сферы).

**C# События (Events)**
Это — сердце компонента. Другие скрипты подписываются на них, чтобы реагировать на ввод.
- `OnPress`: Вызывается в кадре, когда левая кнопка мыши была нажата.
- `OnHold`: Вызывается в каждом кадре, пока левая кнопка мыши удерживается (если включено).
- `OnRelease`: Вызывается в кадре, когда левая кнопка мыши была отпущена.
- `OnClick`: Вызывается при отпускании кнопки, но только если нажатие и отпускание произошли на одном и том же объекте.

---

## 4. Пример использования

Чтобы использовать менеджер, вам не нужно ссылаться на него в инспекторе. Достаточно получить доступ к его синглтону `I` и подписаться на нужные события.

```csharp
using UnityEngine;

public class MyClickListener : MonoBehaviour
{
    private void OnEnable()
    {
        // Подписываемся на событие нажатия
        MouseInputManager.I.OnPress += HandlePress;
    }

    private void OnDisable()
    {
        // Обязательно отписываемся, чтобы избежать утечек памяти
        if (MouseInputManager.I != null) // Проверка на случай, если менеджер уже уничтожен
        {
            MouseInputManager.I.OnPress -= HandlePress;
        }
    }

    private void HandlePress(MouseInputManager.MouseEventData data)
    {
        if (data.HitObject != null)
        {
            Debug.Log($"Нажали на объект: {data.HitObject.name} в точке {data.WorldPosition}");
        }
    }
}
```
